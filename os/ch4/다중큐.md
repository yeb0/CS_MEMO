프로세스의 우선순위는 저마다 다 다르다. 프로세스의 중요도는 프로세스 제어 블록에 표시된다.

준비 상태일 때의 정리되지 않은 프로세스들을 놔 둔다면, CPU는 다음 프로세스를 찾을 때마다 모두 다 뒤져야 찾을 수 있다는 번거로움이 있다.

하지만 우선순위별로 정리해서 올려 둔다면, 우선순위 0번부터 차례대로 실행하면 된다. 이것이 `다중큐`다. 

이 다중큐를 얼마나 둘지 어떻게 둘지는 CPU 스케줄링 알고리즘에 따라 다 다르다. 

- 우선순위를 배정하는 방식은 두 가지가 있다.
  - 고정 우선순위 방식
    - 해당 프로세스가 끝날 때까지 우선순위는 고정되어 바뀌지 않는다. 구현은 쉬우나, 시스템의 변화에는 대응하기 어려움이 있다.
  - 변동 우선순위 방식
    - 프로세스 작업 중간에 우선순위가 변동될 수 있다. 구현은 어렵지만 시스템의 효율성을 더 높일 수 있다.
    - 여기서, 앞의 우선순위보다 뒤의 우선순위가 높아서 순서가 바뀔 경우에 이를 `반전 우선순위`라 한다.

여기까지 준비큐의 상태를 알아보았다. 다른 상태의 큐도 존재한다. `대기큐`

대기 상태는 입출력 프로세스들이 기다리고 있는 상태이다. 시스템 내에는 다양한 입출력이 존재하고, 그만큼 그에 따른 입출력을 기다리는 프로세스들이 존재한다.
그렇기에 한 곳에 몰아 놓으면 관리하기엔 불편하다.(다양하기 때문)

따라서 같은 목적(같은 장치의 입출력이라던지)을 가진 프로세스들끼리 놓아둔다. (대기큐)

앞서 살펴본 준비큐와 대기큐의 차이점은 한 번에 한 개 처리하느냐, 한 번에 여러 개를 처리하느냐의 차이이다.

- 준비큐
  - 하나의 프로세스가 CPU에게 할당받아 사용되는 반면에
- 대기큐
  - 여러 개의 프로세스 제어 블록을 동시에 꺼내어 준비 상태로 옮겨 놓는다.
  - 시스템에는 여러 입출력들이 있기 때문에 입출력이 동시에 끝날 경우 여러 개의 인터럽트가 한꺼번에 처리된다. 
  - 여기서 한번에 처리 하기 위해 `인터럽트 벡터`라는 자료구조를 사용한다.
---

스케줄링 알고리즘에는 여러 가지가 있다. 아침 10시 -> 밤 12시 -> 91 시간 

그 중에서는 일단 두 가지 분류로 나뉘는데, 이전에 알아봤던 선점형/비선점형 알고리즘에 포함된다.

오늘날같이 시분할 시스템으로 이루어진 환경에서는 비선점형 알고리즘은 거의 사용되지 않는다. 비선점형은 CPU 작업을 한 번 잡으면 끝날 때까지 놓질 않으니..

하나씩 알아보자.

### FCFS 스케줄링 방식

**준비 큐에 순서대로 들어온 CPU를 할당하는 비선점형 방식이다. 선입선출 스케줄링이라고도 칭한다.**
마치, League of Le..그 게임 들어갈 때 큐 잡는 것과 같은 방식. FIFO 방식이라고도 부른다. 

순서대로 처리해서 간단하지만, 효율적이지는 못하다. 앞의 할당 시간이 한참 길고 뒤 CPU를 할당받는 시간들이 한참 적은 것들만 남아 있다면
한참을 대기시간만 가져야 한다는 것이다. 이의 문제(효과)를 `콘보이 효과`라고 부른다.

또, 프로세스가 입출력을 요구하는 경우 CPU는 일하지 않고 쉬고 있는 시간이 너무나도 길어져 비효율적이라는 것이다.
시분할 시스템에서야 대기 상태로 보낼 수 있지만, 일괄 작업에서는 보낼 수도 없어서 너무나도 비효율적이다.


### SJF 스케줄링 방식

**준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 방식. 비선점형 방식이다.
최단 작업 우선 스케줄링 방식이라고도 부른다.**

이의 방식은, FCFS 스케줄링 방식에 비해서 완화된 방식이다. 앞 작업이 너무 길어진다면, 뒤의 짧은 작업 시간을 갖는 프로세스들이
앞으로 먼저 와서 처리하는 방식이다. 콘보이 효과를 완화시킬 수 있다는 말이다.

근데 사실 이게 이론상 좋아보이지만 하나의 허점이 존재한다.

P1, P2, P3 프로세스들이 있는데 각각 작업 시간이 30, 5, 9라고 하자. P1, P2, P3 순으로 도착했고, P1이 먼저 실행됐을 때 이게 문제가 생긴다는 것이다.
아니 바꿔 준다고 했는데, 바꿔 줄 수가 없는 것이다. 왜? 비선점형이니까. 게다가 P1이 왔을 적엔 아무도 없었으니 먼저 실행하는 것이고. 그럼 나머진 또 기다려야 되는 것이다.

그리고 또 문제점들이 여러 존재한다.

그럼 만약에 그 뒤로 P4가 작업 시간이 6이라 한다면? 그럼 P3는 또 밀려난다. 계속해서 이런 식으로 밀려나면 P3 작업은 못한다.. 이를 `무한 봉쇄 현상, 아사 현상`이라고 한다.

그리고 OS는 프로세스의 종료 시간을 정확하게 알 수 없다. 

물론 이 문제점들을 해결할 수는 있다. OS에게 미리 작업 종료 시간을 알려 준다던지, 에이징처리(나이를 먹임)하여 아사 현상을 막는다던지.
하지만 역시 잘 안 쓰인다.


### HRN 스케줄링 방식

SJF 스케줄링에서 아사 현상을 해결하기 위해 만들어진 비선점형 방식이다.

우선순위를 따로 내부적으로 계산하여 아사현상을 완화시킨다. 하지만 이 방식도 공평성에 위배되어 많이 사용되지는 않는다.

### RR 스케줄링 방식

라운드로빈 스케줄링이다. 한 프로세스가 할당 받은 시간 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서
자기 차례를 기다리는 방식이다.(순환 순서 방식) 선점형 방식이다.

FCFS와 유사한데, 다른 점이라면 각 프로세스 마다 CPU를 사용할 수 있는 최대 시간(타임 슬라이스)이 있다는 것이다.
우선순위는 적용되지 않는다.

이것도 문제점이 있는데, 타임 슬라이스가 큰 경우에는 하나의 작업이 끝난 후 다음 작업이 시작되는 것처럼 보인다.
이 경우는 FCFS와 사실 다를 바가 없다.

역으로 타임 슬라이스가 작을 경우에는 문맥교환이 너무 많이 일어나서 오버헤드라는 점이다.

### SRT 스케줄링 방식

SJF 스케줄링 + RR 스케줄링의 방식이다.SJF 스케줄링의 선점형 방식이라 할 수 있다.

SRT 스케줄링 방식은 기본적으로 RR 스케줄링 방식을 사용하지만, CPU를 할당 받을 프로세스를 선택할 때 남아 있는 작업 시간이
가장 적은 프로세스를 선택한다. **남은 시간이 적은 프로세스에 CPU를 할당한다.**

이 방식도 좋지만은 않다. 문제점들이 존재하는데,

현재 실행 중인 프로세스와 현재 큐에 있는 프로세스의 남은 시간을 주기적으로 계산하는 작업, 그리고 가장 적은 시간을 갖는 프로세스와 문맥교환 해야한다는 점.
SRT 스케줄링 방식에는 없는 작업이 추가가 되는 셈이다. 그리고 SJF처럼 아사현상이 일어날 수 있으므로 잘 사용되지 않는다.

### 우선순위 스케줄링 방식

프로세스는 중요도에 따라 우선순위가 결정된다 했다. 이 우선순위를 반영한 스케줄링 알고리즘이 바로 이것이다.

이 내부에서 무엇을 우선순위로 둘 것인가 결정할 수 있다. 이 방식은 공평성을 위배하고, 아사 현상을 일으킬 수 있다.
그리고 준비 큐에 있는 프로세스의 순서를 무시하고 프로세스의 우선순위를 매번 바꿔줘야 하는 작업이 오버헤드를 발생시킨다.

### 다단계 큐 스케줄링

우선순위에 따라 준비 큐를 여러 개 사용하는 방식이다. 

우선순위에 따라 다양한 스케줄링이 가능한 선점형 방식이다. 우선순위가 높은 프로세스가 먼저 실행될 수 있고, 우선순위에 따라
타임 슬라이스를 조절하여 작업 효율도 높일 수 있다. 프로세스의 우선순위와 작업 형태를 고려해 스케줄링을 할 수 있다.(커스텀 마냥)

우선순위 1번인 큐에 CPU 할당을 기다리는 프로세스가 있다. 그렇다면 우선순위 2번인 큐의 프로세스는 1번 큐에 있는 프로세스가 작업이 끝날 때까지
기다려야 한다. 이렇게 되면 작업이 연기가 되는데, 이를 해결하기 위해 제안된 것이 다단계 피드백 큐 스케줄링이다.


### 다단계 피드백 큐 스케줄링

우선순위가 낮은 프로세스에 불리한 다단계 큐 스케줄링의 문제점을 보완한 방식이다. 다단계 큐 스케줄링과 기본적인 형태가 같아 우선순위를 가진 여러 개의 큐를 가진다.

프로세스가 CPU를 한 번씩 할당받아 실행될 때마다 프로세스의 우선순위를 낮춤으로써, 다단계 큐에서 우선순위가 낮은 프로세스의 실행이
연기되는 문제를 완화한다.