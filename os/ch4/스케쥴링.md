#### 스케쥴링은 CPU를 어떤 작업에 배정할까?를 논한다.

스케쥴링은 규모에 따라서 분류될 수 있다. 고수준 스케줄링, 중간수준 스케줄링, 저수준 스케줄링이 있다.

- 고수준 스케줄링
  - 시스템 내의 전체 작업 수를 조절하는 것을 맡는다. 
  - 이 작업은 OS에서 다루는 일의 가장 큰 단위로, 1개 또는 여러 개의 프로세스로 이루어진다.
  - 그래서 어떤 작업을 시스템이 받아들일지 OR 거부할지 결정해준다.
    - 그냥 쉽게 얘기해서, 식당 상황 고려 안 하고 손님 수 뒤지게 받을 수 없으니 알아서 판단해서 조절해주는 것이다.

- 저수준 스케줄링
  - 어떤 프로세스에 CPU를 할당할지? 어떤 프로세스를 대기 상태로 보낼지 등을 결정한다.
  - 이전에 ch3에서 배웠던 프로세스와 스레드 부분 중 프로세스 상태 변화에 이르렀던 그 일들은 저수준 스케줄링에 포함된다.

- 중간수준 스케줄링
  - 중지와 활성화로 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다.
  - 너무 큰 프로세스는 잠시 중지 상태로 만들고, 나머지 프로세스가 원활히 작동하길 유도해주는 방식이라 보면 된다.
### 스케줄링의 목적 
이 스케줄링의 목적은 CPU를 골고루 사용하게끔 하는 것이 주 목적이다. 하지만, 일부 프로세스가 뒤로 밀려나서(우선순위)
뒤의 프로세스가 작업이 먼저 이루어진다던지? 공평성을 희생해야할 순간들이 있다.

#### 이러한 방식에도 분류가 되어 있다.

- 선점형 스케줄링
  - 어떤 프로세스가 CPU를 할당받아 작업을 하고 있음에도 불구하고 `강제로` 빼앗아 자기가 사용할 수 있다.
  - 문맥 교환 같이 부가적인 작업으로 인해 오버헤드가 생긴다는 것이 단점.
  - 하지만 하나의 프로세스만이 CPU를 독점할 수 없다. 따라서 대화형이나 시분할 시스템에 적합하다.

- 비선점형 스케줄링
  - 어떤 프로세스가 CPU를 할당받아 작업을 하고 있다면, 그 CPU는 빼앗을 수 없다.
  - 문맥 교환 같이 부가적인 작업들이 비교적으로 적기 때문에 오버헤드는 생기지 않는다.
  - 하지만 어떤 한 프로세스가 오래 작업을 하고 있다면, 그에 비해 짧은 프로세스들은 그만큼 기다려야만 한다. 따라서 처리율이 떨어진다는 것.

#### 프로세스에는 우선순위가 있다. (물론 위의 선점/비선점만 봐도 예상이 가겠지만)

#### 프로세스는 크게 커널 프로세스, 일반 프로세스가 있다. 커널 프로세스가 더 우선순위가 높은 편이다.

따라서 커널/일반 두 개의 프로세스가 있다면 커널 프로세스가 더 먼저 실행이 된다. 하지만 이 커널 프로세스 중에서도 또 우선순위가 나뉠 수 있는데
여기에서도 더 높은 순서대로 실행이 된다.

#### 또, 프로세스에 두 가지 종류로 나눌 수 있다.

프로세스 상태 즉, 실행/대기 상태일 때마다 프로세스가 다르다. 
대기 상태일 때는 주로 입출력이라고 했었는데, 맞다. 이를 입출력 집중 프로세스라 칭한다. 실행상태일 때는 CPU 집중 프로세스라 한다.

그리고 프로세스가 실행할 때에는 CPU 버스트 한다고도 표현한다. 대기상태일 때는 입출력 버스트라고도 표현한다.

프로세스를 조금 더 효율적으로 사용하기 위해서는 입출력 프로세스를 더 우선순위로 두는 것이 효율적이다. 
왜냐하면, 입출력 프로세스를 먼저 CPU를 사용할 경우 입출력을 위해 대기 상태로 진입하므로, 다른 프로세스가 CPU를 더 많이 사용할 수 있기 때문이다.
그렇게 될 경우, 어떤 다른 프로세스가 사용하고 타임아웃 후, 입출력을 실행하고 다시 반복하는 과정이 진행된다.

이렇게 입출력 프로세스가 먼저 사용되는 것(경우)을 사이클 훔치기(cycle stealing)라고도 한다.

이어서, 다중 큐로 내용이 이어진다.