메모리는 1B 크기로 나뉜다. 각각의 칸이 있다고 가정하고, 한 칸 당 1B씩 있는 셈이다.
배열처럼 0번지부터 시작한다. 

CPU는 메모리에 있는 내용을 가져 오거나 작업 결과를 메모리에 저장하기 위해 메모리 주소 레지스터(MAR)를 사용한다.

이 메모리 주소 레지스터에 필요한 메모리 주소를 넣어두면 데이터를 메모리에서 가져 오거나 메모리에 데이터를 옮길 수 있게 된다.

오늘날 컴퓨터는 폰노이만 구조로, 모든 프로그램은 메모리 상 위에 올라와야 실행이 가능하다.

시분할 시스템은 OS를 포함해 모든 응용 프로그램이 메모리에 올라와 실행되기 때문에 메모리 관리가 복잡하다.(여러 프로그램들이 시분할 방식으로 진행되기 때문이다.)
마치 도마 위에 음식 재료들을 올려 두고 손질하는 것과 같다.

OS도 응용프로그램이다. 따라서 메모리엔 OS 뿐만 아니라 사용자 응용 프로그램도 같이 동작하게 되는 것이다.

(부팅을 하게 될 때, 하드디스크에 저장된 OS가 메모리 위에 올라간다. 부팅이 끝나면 여러 응용 프로그램이 메모리에서 작업할 수 있게 되는 것.)

이 여러 작업들을 동시에 처리할 때 메모리를 어떻게 관리하게 될까? 이는 메모리 관리 시스템이 담당한다.

메모리 관리의 이중성은 아래의 예로부터 나온다.

도마 위에 음식 재료가 하나만 있다면 관리하기에 수월하지만, 여러 재료들이 있을 경우엔 재료 손질이 쉽지 않다.
더군다나 그 재료들만 존재한다면 모를까. 또다른 재료들이 계속해서 들어올 수도 있다.

이럴 경우에 더 크기(할당된 공간)가 크다면 옆의 재료를 밀어내거나 더 큰 공간으로 해당 재료를 옮겨준다. 

이처럼 매번 작업 공간을 키웠다 줄였다 하는 방식은 매우 매우 복잡하다.

때문에 재료(프로세스)에서 작업의 편리함과 관리자 입장에서 관리의 편안함이 충돌을 일으키는 것을 말한다.

---
보통 응용 프로그램들은 프로그래밍 언어로 만들어져 있다. 보통은 컴파일러를 사용하여 작성한 프로그램을 실행 가능한 코드로 변경한다.

저급 언어로 변경하는데, 0과 1로만 존재하는 기계어로 변환하는 것이다. 이와 비슷한 어셈블리어도 마찬가지.

기계어와 어셈블리어는 저급 언어라 한다. 이의 반대로 고급 언어가 있는데, 예시로 자바, C 언어가 있다.

이 고급 언어들은 컴퓨터가 읽지 못해 저급 언어로 변경해 주어야 한다. 이의 과정 속에 컴파일러와 인터프리터가 존재한다.

- 컴파일러 : 소스코드를 컴퓨터가 실행할 수 있는 기계어로 번역한 후 한번에 실행한다. C 언어, Java 등이 사용한다.
- 인터프리터 : 소스코드를 한 행씩 번역하여 실행한다. JS, 베이직 등이 있다.

